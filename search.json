[
  {
    "objectID": "scicomp/week5.html",
    "href": "scicomp/week5.html",
    "title": "Week 5: The 2D Poisson equation",
    "section": "",
    "text": "\\[\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n\\]\n\nOverview\nThis week, we will use finite differences to solve PDEs in two dimensions. Particular focus will be placed on solving Poisson’s equation. For 2D problems, the number of unknowns and hence the size of the linear systems quickly grow as the number of grid points is increased. Sparse matrices, which only store the non-zero elements of a matrix, can lead to substantial reductions in the memory that needed to numerically solve the PDE, especially for 2D problems.\n\n\nExercises\n\nSolve the Poisson equation \\[\n\\nabla^2 u + 1 = 0\n\\] on the domain \\(a \\leq x \\leq b\\) and \\(c \\leq y \\leq d\\). Assume that \\(u = 0\\) on the boundaries.\nUse memory profiling to determine how much memory is required to solve the problem in Exercise 1. How does the memory usage depend on the number of grid points?\nGeneralise your code from Exercise 1 so that it can solve problems of the form \\[\nD \\nabla^2 u + q(x,y) = 0.\n\\] To validate your code, set \\[\nq(x,y) = -D \\pi^2 \\left[\\frac{1}{(b-a)^2} + \\frac{1}{(d-c)^2}\\right]\\sin\\left[\\frac{\\pi(x-a)}{b-a}\\right]\\sin\\left[\\frac{\\pi(y-c)}{d-c}\\right];\n\\] in this case, the exact solution to the problem is given by \\[\nu(x,y) = \\sin\\left[\\frac{\\pi(x-a)}{b-a}\\right]\\sin\\left[\\frac{\\pi(y-c)}{d-c}\\right].\n\\]\nFurther generalise your code so that non-homogeneous Dirichlet boundary conditions can be used. For example, solve the Poisson equation for Exercise 1 but replace the boundary condition at \\(x = a\\) with \\(u(a, y) = \\sin(\\pi(y-c)/(d-c))\\).\nUse sparse matrices to solve the 1D Poisson equation given by \\[\n\\tdd{u}{x} + 1 = 0\n\\] with \\(u(0) = u(1) = 0\\).\n\nFirst use 101 grid points (\\(N = 100\\)). Time your code and profile its memory usage. Is your sparse code faster and more memory efficient than your previous code?\nRepeat part (a) but now use \\(N = 1000\\). If you have correctly implemented sparse matrices, then you should now see a significant speed up and memory reduction.\n\nSolve the 2D Poisson equation with sparse matrices."
  },
  {
    "objectID": "scicomp/week3.html",
    "href": "scicomp/week3.html",
    "title": "Week 3: Diffusion equations in 1D",
    "section": "",
    "text": "\\[\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n\\]\n\nOverview\nThis week we enter the realm of numerically solving partial differential equations (PDEs). We will focus on one of the most important PDEs of them all: the diffusion equation. By using finite differences to discretise space, the diffusion equation can be converted into a system of ODEs. There are two main ways to solve this ODE system.\nThe explicit Euler method is the simplest method, and it can be extended to nonlinear problems relatively easily. However, the method only works if the time step \\(\\Delta t\\) is sufficiently small. This means that a large number of time steps may be required to obtain a solution.\nThe implicit Euler method is more complex because it involves solving a system of algebraic equations at each time step. Howver, larger values of the time step \\(\\Delta t\\) are usually possible. In fact, for the linear diffusion equations, the implicit Euler method is unconditionally stable, meaning it will work for any time step size \\(\\Delta t\\). The need to solve an algebraic system of equations at each time step comes at a high computational cost. Hence, there is a tradeoff between being able to take fewer time steps to obtain a numerical solution and the higher computational cost per time step.\n\n\nSupplementary material\nUse the links below to find additional notes on\n\nSome solutions to the diffusion equation\n\n\n\nExercises\nThe goal of this week is to develop code that can solve reaction-diffusion equations of the form \\[\n\\pd{u}{t} = D \\pdd{u}{x} + q(x, t, u; \\mu), \\tag{1}\n\\] where the diffusion coefficient \\(D &gt; 0\\). The domain of the problem is given by \\(a \\leq x \\leq b\\). The term \\(q(x, t, u; \\mu)\\) represents a function that depends on the spatial coordinate \\(x\\), time \\(t\\), the solution \\(u(x, t)\\), and a parameter \\(\\mu\\).\nYour code should be able to handle all combinations of boundary conditions. You should implement both the explicit and implicit Euler method.\n\nUse the explicit Euler method to solve the linear diffusion equation without a source term \\[\n\\pd{u}{t} = D\\pdd{u}{x}.\n\\] Set the boundary conditions to \\(u(a,t) = 0\\) and \\(u(b,t) = 0\\) and the initial condition to \\[\nu(x,0) = \\sin\\left(\\frac{\\pi (x - a)}{b - a}\\right).\n\\]\nThe exact solution to the problem is given by \\[\nu(x, t) =  \\exp\\left(-\\frac{D \\pi^2 t}{(b-a)^2}\\right)\\sin\\left(\\frac{\\pi (x - a)}{b - a}\\right).\n\\] which you can use to test your code.\nUse the implicit Euler method to solve the problem in Exercise 1, using the same analytical solution to validate your code.\nExplicit vs implicit Euler. In this exercise, you will compare the performance of the two Euler methods. Consider the diffusion equation and boundary conditions from Exercise 1. Take \\(a = 0\\), \\(b = 1\\), and \\(D = 0.1\\). Discretise the spatial domain using 31 grid points (\\(N = 30\\)) and solve the problem until time \\(T = 1\\).\n\nFix the time step to be \\(\\Delta t = 0.005\\). Show that this time step is smaller than the maximum time step that can be used with the explicit Euler method. Solve the problem using the explicit and implicit Euler method. Which method is the fastest and why?\nIncrease the time step to \\(\\Delta t = 0.1\\) and solve with the implicit Euler method. How does the speed of the implicit Euler method now compare to the speed of the explicit Euler method with \\(\\Delta t = 0.005\\)? Which of the two methods leads to a more accurate solution when \\(t = 1\\)?\n\nExtend your code so that it can solve linear reaction-diffusion equations of the form \\[\n\\pd{u}{t} = D \\pdd{u}{x} + q(x), \\\\\n\\] with two Dirichlet boundary conditions. Use the supplementary notes to find exact solutions that you can use to test your code with.\nSolve the Fisher-KPP equation (a nonlinear reaction-diffusion equation) given by \\[\n\\pd{u}{t} = D\\pdd{u}{x} + r u (1 - u)\n\\] on the domain \\(0 \\leq x \\leq 10\\). The boundary and initial conditions are \\[\nu(0,t) = 1, \\qquad u(10,t) = 0, \\qquad u(x,0) = 0.\n\\] You can take \\(D = 0.1\\) and \\(r = 2\\). Run your simulation until \\(t = 20\\) and use 51 grid points (\\(N = 50\\)). What types of solution do you see?\nHint: It may help to code up an explicit Euler method for this problem first due to its simplicity. Then, implement an implicit Euler method, and validate the results by comparing with your explicit Euler method.\nExtend your code so that it can handle Neumann and Robin boundary conditions. One way to start this process is to solve \\[\n\\pd{u}{t} = D\\pdd{u}{x}\n\\] with boundary conditions given by \\[\n\\quad u(0,t) = 0, \\quad D\\left.\\pd{u}{x}\\right|_{x=L} = j,  \\quad u(x,0) = 0.\n\\] Hint: To validate your code, you can find an exact solution to this problem using the separation of variables. Alternatively, you can take \\(L \\gg 1\\) (e.g. \\(L = 10\\)) and use the similarity solution in the supplementary notes, which gives \\(u(L,t) \\simeq j(4 t / \\pi D)^{1/2}\\) for sufficiently small values of \\(t\\)."
  },
  {
    "objectID": "scicomp/week2.html",
    "href": "scicomp/week2.html",
    "title": "Week 2: ODE BVPs",
    "section": "",
    "text": "\\[\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n\\]\n\nOverview\nThis week showcase how finite difference methods can be used to solve boundary value problems (BVPs) for ODEs. In short, the finite difference method converts ODEs into algebraic systems of equations, which can then be solved using two main approaches:\n\nWriting your own solvers using linear algebra functions.\nUsing built-in solvers provided by Python (SciPy) and Matlab.\n\nThe code that you develop this week will form an essential role in the upcoming weeks when the focus shifts towards numerically solving partial differential equations.\n\n\nExercises\nThe goal of the exercises is to create a BVP solver that is capable of finding numerical solutions to ODEs of the form \\[\nD \\tdd{u}{x} + q(x, u; \\mu) = 0,\n\\] where the domain of the problem is given by \\(a \\leq x \\leq b\\). In this equation, \\(D &gt; 0\\) is a parameter. The term \\(q(x, u; \\mu)\\) represents a function that depends on the spatial coordinate \\(x\\), the solution \\(u(x)\\), and a parameter \\(\\mu\\). Your solver should be able to handle all three types of boundary conditions (Dirichlet, Neumann, and Robin).\nBuilding this solver is a big task. The exercises below are designed so that you can see how to build your code by solving a sequence of simpler problems. Test your code extensively and only add complexity once you are certain it works correctly.\n\nUse finite differences to find a numerical solution to \\[\n\\tdd{u}{x} = 0, \\quad\nu(a) = \\gamma_1, \\quad u(b) = \\gamma_2.\n\\] In this case, the exact solution to the problem is given by \\[\nu(x) =  \\left(\\frac{\\gamma_2 - \\gamma_1}{b-a}\\right)(x - a) + \\gamma_1, \\tag{1}\n\\] which you can use to test your code.\nExtend your code so that it can account for a source term in the ODE: \\[\nD \\tdd{u}{x} + q(x) = 0, \\quad\nu(a) = \\gamma_1, \\quad u(b) = \\gamma_2.\n\\] Hint: The simplest place to start is to set \\(q(x) = 1\\); in this case, the exact solution is given by \\[\nu(x) = -\\frac{1}{2D}(x-a)(x-b) +  \\left(\\frac{\\gamma_2 - \\gamma_1}{b-a}\\right)(x - a) + \\gamma_1.\n\\] Once you’ve developed code for the problem with \\(q(x) = 1\\), add an \\(x\\) dependence into \\(q\\). Can you find some exact solutions for this case?\nGeneralise your code so that the source term \\(q\\) can now depend on the solution \\(u\\) as well as a parameter \\(\\mu\\). Use your code to solve the equation \\[\n\\tdd{\\phi}{x} + \\mu(\\phi - \\phi^3) = 0\n\\] with the boundary conditions \\(\\phi(-1) = -1\\) and \\(\\phi(1) = 1\\) when (a) \\(\\mu = 0.5\\) and (b) \\(\\mu = 100\\).\nHint 1: If \\(q\\) depends nonlinearly on the solution, as with this problem, then a good initial guess of the solution is usually required for the nonlinear solver to converge. For this problem, a good initial guess can be found by noting that when \\(\\mu\\) is small, the source term \\(q\\) is approximately zero. The solution in this case is given by (1), which can be used to form an initial guess.\nHint 2: If you find it difficult to obtain a solution when \\(\\mu = 100\\), then try to increase \\(\\mu\\) in increments from \\(0.5\\) to \\(100\\). Each time a new solution is successfully computed, use it as the initial guess for the next (larger) value of \\(\\mu\\). This process of gradually ramping up a parameter and using the previously computed solution as the next initial guess is called natural parameter continuation.\n(Optional) Solve the previous exercise using your own implementation of Newton’s method and a built-in algebraic solver (e.g. root or fsolve). Compare the performance of the solver. What solver is more likely to converge? Answer: you should see that Newton’s method is more likely to converge (assuming you’re using the default options with the built-in solver).\nUpdate your code so that it can account for any combination of Dirichlet, Neumann, and Robin boundary conditions. Remember to validate your code against problems with known solutions!\nTry using your code to solve the problem \\[\n\\tdd{u}{x} + 1 = 0, \\quad \\left.\\td{u}{x}\\right|_{x=\\pm 1} = 0.\n\\] To understand what happens in this case, try solving this problem by hand. Alternatively, integrate the ODE and impose the boundary conditions."
  },
  {
    "objectID": "optim/overview.html",
    "href": "optim/overview.html",
    "title": "Scientific Computing: Overview",
    "section": "",
    "text": "Weeks 7–11\nThe purpose of this bit is…"
  },
  {
    "objectID": "assessment.html",
    "href": "assessment.html",
    "title": "Assessment",
    "section": "",
    "text": "This unit will be assessed by a single piece of coursework. It will be released in two parts, one in week 5 and one in week 9.\nThe final deadline is 12 noon on Friday of week 11. Submit your coursework as a PDF via Blackboard."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing and Optimisation",
    "section": "",
    "text": "This unit will bring together your previous experience of solving mathematical problems (optimisation, differential equations) and writing computer programmes using Python, Matlab, or Julia. The aim is to provide you with a suite of tools that can be used to transform real-world problems, such as those encountered in the Mathematical and Data Modelling units and final-year projects, into problems that can be efficiently solved on a computer.\n\nUnit timetable\n\nWeek 1: Finite differences and Euler’s method\nWeek 2: ODE boundary value problems\nWeek 3: Diffusion equations in 1D\nWeek 4: First-order PDEs in 1D\nWeek 5: The 2D Poisson equation\nWeek 6: Reading week (no sessions)\nWeek 7:\nWeek 8:\nWeek 9:\nWeek 10:\nWeek 11: Coursework support\nWeek 12: TBD\n\n\n\nSoftware\nYou can code in Python, Matlab, or Julia. The choice is yours. However, some demos and examples will only be provided in one programming language.\n\n\nTeaching sessions\nAll teaching sessions will take place in MVB 1.15.\n\nMonday ????: demo and Q&A session\nThursday 1600-1800: lab session\nFriday ????: drop-in (optional)\n\n\n\nTeaching staff\n\nDr Matthew Hennessy (unit director): matthew.hennessy@bristol.ac.uk\nProf David Barton (unit lecturer): david.barton@bristol.ac.uk\nMr Roussel Desmond Nzoyem (teaching assistant): rd.nzoyemngueguin@bristol.ac.uk"
  },
  {
    "objectID": "scicomp/overview.html",
    "href": "scicomp/overview.html",
    "title": "Scientific Computing: overview",
    "section": "",
    "text": "The first five weeks will focus on how scientific computing can be applied to the numerical solution of ordinary and partial differential equations. Although differential equations appear in many engineering contexts, they usually cannot be solved by hand. Instead, numerical methods are needed to compute an approximate solution.\n\nWeek 1: Finite differences and Euler’s method\nWeek 2: ODE boundary value problems\nWeek 3: Diffusion equations in 1D\nWeek 4: First-order PDEs in 1D\nWeek 5: The 2D Poisson equation"
  },
  {
    "objectID": "scicomp/week1.html",
    "href": "scicomp/week1.html",
    "title": "Week 1: Finite differences and Euler’s method",
    "section": "",
    "text": "\\[\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n\\]\n\nOverview\nTo start off the unit, we dive into finite differences. This is a general method for approximating derivatives of mathematical functions with algebraic formulae. This will be a crucial step when it comes to deriving numerical methods for solving ODEs and PDEs. We also introduce the idea of truncation error, explain why this is useful, and how it can be calculated using Taylor expansions. Finally, we recap Euler’s method, a simple yet useful approach for numerically approximating the solution of time-dependent ODEs.\n\n\nSupplementary material\n\nNotes on the derivation of finite-difference formulae using Taylor expansions\n\n\n\nExercises\n\nConsider the following finite-difference approximation of the second derivative \\[\n\\left.\\tdd{u}{x}\\right|_{x=a} = \\frac{2 u(a) + C u(a+\\Delta x) + 4u(a + 2 \\Delta x) - u(a + 3\\Delta x)}{(\\Delta x)^2}\n\\] First, take \\(C = 5\\). By calculating the truncation error analytically or numerically, determine whether this is a valid approximation formula. If the formula is valid, determine the order of the approximation. Is the approximation formula valid when \\(C = -5\\)? If so, what is the order of the approximation?\nImplement a version of Euler’s method that can solve an arbitrary system of ODEs of the form \\[\n\\td{\\vec{u}}{t} = \\vec{f}(\\vec{u}, t, \\mu),\n\\] where \\(\\mu\\) represents one or many parameters that the function \\(\\boldsymbol{f}\\) might depend on. The initial condition is \\(\\boldsymbol{u}(0) = \\boldsymbol{u}_0\\).\nValidate your implementation of Euler’s method by numerically solving the system of ODEs given by \\[\n\\td{u_1}{t} = -\\omega u_2, \\qquad\n\\td{u_2}{t} = \\omega u_1, \\tag{1}\n\\] over the time range \\(0 \\leq t \\leq 2 \\pi\\). The initial condition can be set to \\(u_1(0) = 1\\) and \\(u_2(0) = 0\\). The exact solution to this problem is given by \\(u_1(t) = \\cos(\\omega t)\\) and \\(u_2(t) = \\sin (\\omega t)\\).\n\nSet \\(\\omega = 1\\) and use \\(N_t = 100\\) time steps to find a numerical solution. Plot \\(u_1\\) as a function of time using your numerical solution and the exact solution.\n\nKeeping \\(\\omega = 1\\), create similar plots when \\(N_t\\) is decreased to 50 and increased to 1000. From the plots, what happens to the accuracy of the numerical solution as \\(N_t\\) increases?\n\nFor the ODE system given by (1), use numerical experimentation to determine how different values of \\(\\omega\\) impact the solution. If \\(u_1\\) represents the displacement of a mass on a spring, then what does \\(\\omega\\) physically correspond to?\nFor the ODE system given by (1), compute the error between your numerical solution and the exact solution at time \\(t = 2 \\pi\\); that is, calculate \\(\\varepsilon = |u_1^{N_t} - 1|\\), where \\(u_1^{N_t}\\) is the numerical solution at time step \\(N_t\\).\n\nFor a fixed value of \\(\\omega = 1\\), how fast does the error decrease with \\(\\Delta t\\)? Is it linear, quadratic, etc? Is this what you expect based on the truncation error of Euler’s method?\n\nFor a fixed number of time steps, \\(N_t = 10^4\\), how does the error change as \\(\\omega\\) increases? Can you provide a justification of the results you see? For this problem, try setting \\(\\omega = 1, 2, 4, 8, 16\\).\n\n\n\n\nCoursework-style problem\nConsider a pack of \\(N\\) identical lithium-ion batteries that are connected in series. Let \\(i = 1\\) denote the first battery in the pack and \\(i = N\\) denote the last battery in the pack. The other batteries are labelled with \\(i = 2, 3, \\ldots, N - 1\\). Due to the geometry of the pack, only batteries 1 and \\(N\\) are in contact with the environment. Battery \\(i\\) is in contact with batteries \\(i-1\\) and \\(i + 1\\).\nEach battery in the pack acts as a resistor. When an electrical current is drawn from the battery pack, each battery will heat up due to Joule heating. The heat that is generated in battery \\(i\\) will be transferred to batteries \\(i-1\\) and \\(i + 1\\), causing these two batteries to heat up even more. Heat is transferred from one battery to the next until it reaches batteries 1 and \\(N\\), which can then transfer the heat to the air. The more batteries there are, the longer the generated heat remains in the battery pack, and the hotter the pack will get. If the temperature of any battery exceeds 60 \\(^\\circ\\)C, then it will start to degrade. Battery degradation is extremely dangerous, as this can lead to the release of toxic and explosive gases.\nThe aim of this exercise is to simulate the temperature of a battery pack in order to determine whether it is expected to be safe to use.\nAssume that a constant current \\(I\\) is being drawn from the battery pack. If \\(T_i(t)\\) denotes the temperature of battery \\(i\\) at time \\(t\\), then the temperature of each of the batteries can be obtained by solving the ODE system given by \\[\\begin{align}\nc \\td{T_1}{t} &= I^2 R - h(T_{1} - T_\\text{air}) - h(T_{1} - T_{2}), \\tag{2} \\\\\nc \\td{T_i}{t} &= I^2 R - h(T_{i} - T_{i-1}) - h(T_{i} - T_{i+1}), \\quad i = 2, 3, \\ldots, N - 1, \\tag{3} \\\\\nc \\td{T_N}{t} &= I^2 R - h(T_{N} - T_\\text{air}) - h(T_{N} - T_{N-1}). \\tag{4}\n\\end{align}\\] Here, \\(c\\) is the specific heat of the battery, \\(R\\) is the resistance of the battery, \\(h\\) is the heat transfer coefficient, and \\(T_\\text{air}\\) is the temperature of the air. Values for these parameters are given in the table below. You can assume that the initial temperature of each battery is given by \\(T_\\text{air}\\); that is, \\(T_i(0) = T_\\text{air}\\).\n\nParameter values for each battery.\n\n\n\n\n\n\n\n\n\n\\(I\\) (A)\n\\(c\\) (J/\\(^\\circ\\)C)\n\\(h\\) (W/\\(^\\circ\\)C)\n\\(T_\\text{air}\\) (\\(^\\circ\\)C)\n\\(R\\) (Ohms)\n\n\n\n\n3\n300\n0.7\n23\n0.4\n\n\n\nIn the exercises below, assume that the current is being drawn for one hour.\n\nConsider a battery pack with \\(N = 5\\) batteries.\n\nNumerically solve the ODE system in (2)–(4). Create a single plot that shows the temperature of each battery as a function of time.\nAt each time \\(t\\), compute the maximum temperature across all 6 batteries. Plot the maximum temperature as a function of time.\nUse your results to determine whether the battery is safe to use. Answer: yes.\n\nIs a battery pack with \\(N = 50\\) batteries safe to use? Answer: no.\nWhat is the largest number of batteries that a pack can contain yet still be safe to use? Answer: 11."
  }
]