[
  {
    "objectID": "scicomp/week1.html",
    "href": "scicomp/week1.html",
    "title": "Week 1: Finite differences and Euler’s method",
    "section": "",
    "text": "\\[\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n\\]\n\nOverview\nTo start off the unit, we dive into finite differences. This is a general method for approximating derivatives of mathematical functions with algebraic formulae. This will be a crucial step when it comes to deriving numerical methods for solving ODEs and PDEs. We also introduce the idea of truncation error, explain why this is useful, and how it can be calculated using Taylor expansions. Finally, we recap Euler’s method, a simple yet useful approach for numerically approximating the solution of time-dependent ODEs.\n\n\nSupplementary material\n\nNotes on the derivation of finite-difference formulae using Taylor expansions\n\n\n\nExercises\n\nConsider the following finite-difference approximation of the second derivative \\[\n\\left.\\tdd{u}{x}\\right|_{x=a} = \\frac{2 u(a) + C u(a+\\Delta x) + 4u(a + 2 \\Delta x) - u(a + 3\\Delta x)}{(\\Delta x)^2}\n\\] First, take \\(C = 5\\). By calculating the truncation error analytically or numerically, determine whether this is a valid approximation formula. If the formula is valid, determine the order of the approximation. Is the approximation formula valid when \\(C = -5\\)? If so, what is the order of the approximation?\nImplement a version of Euler’s method (with for loops or using vectorisation) that can solve an arbitrary system of ODEs of the form \\[\n\\td{\\vec{u}}{t} = \\vec{f}(\\vec{u}, t, \\mu),\n\\] where \\(\\mu\\) represents one or many parameters that the function \\(\\boldsymbol{f}\\) might depend on. The initial condition is \\(\\boldsymbol{u}(0) = \\boldsymbol{u}_0\\).\nValidate your implementation of Euler’s method by numerically solving the system of ODEs given by \\[\n\\td{u_1}{t} = -\\omega u_2, \\qquad\n\\td{u_2}{t} = \\omega u_1, \\tag{1}\n\\] over the time range \\(0 \\leq t \\leq 2 \\pi\\). The initial condition can be set to \\(u_1(0) = 1\\) and \\(u_2(0) = 0\\). The exact solution to this problem is given by \\(u_1(t) = \\cos(\\omega t)\\) and \\(u_2(t) = \\sin (\\omega t)\\).\n\nSet \\(\\omega = 1\\) and use \\(N_t = 100\\) time steps to find a numerical solution. Plot \\(u_1\\) as a function of time using your numerical solution and the exact solution.\n\nKeeping \\(\\omega = 1\\), create similar plots when \\(N_t\\) is decreased to 50 and increased to 1000. From the plots, what happens to the accuracy of the numerical solution as \\(N_t\\) increases?\n\nFor the ODE system given by (1), use numerical experimentation to determine how different values of \\(\\omega\\) impact the solution. If \\(u_1\\) represents the displacement of a mass on a spring, then what does \\(\\omega\\) physically correspond to?\nFor the ODE system given by (1), compute the error between your numerical solution and the exact solution at time \\(t = 2 \\pi\\); that is, calculate \\(\\varepsilon = |u_1^{N_t} - 1|\\), where \\(u_1^{N_t}\\) is the numerical solution at time step \\(N_t\\).\n\nFor a fixed value of \\(\\omega = 1\\), how fast does the error decrease with \\(\\Delta t\\)? Is it linear, quadratic, etc? Is this what you expect based on the truncation error of Euler’s method?\n\nFor a fixed number of time steps, \\(N_t = 10^4\\), how does the error change as \\(\\omega\\) increases? Can you provide a justification of the results you see? For this problem, try setting \\(\\omega = 1, 2, 4, 8, 16\\).\n\n\n\nCoursework-style exercise\nConsider a pack of \\(N\\) identical lithium-ion batteries that are connected in series. Let \\(i = 1\\) denote the first battery in the pack and \\(i = N\\) denote the last battery in the pack. The other batteries are labelled with \\(i = 2, 3, \\ldots, N - 1\\). Due to the geometry of the pack, only batteries 1 and \\(N\\) are in contact with the environment. Battery \\(i\\) is in contact with batteries \\(i-1\\) and \\(i + 1\\).\nEach battery in the pack acts as a resistor. When an electrical current is drawn from the battery pack, each battery will heat up due to Joule heating. The heat that is generated in battery \\(i\\) will be transferred to batteries \\(i-1\\) and \\(i + 1\\), causing these two batteries to heat up even more. Heat is transferred from one battery to the next until it reaches batteries 1 and \\(N\\), which can then transfer the heat to the air. The more batteries there are, the longer the generated heat remains in the battery pack, and the hotter the pack will get. If the temperature of any battery exceeds 60 \\(^\\circ\\)C, then it will start to degrade. Battery degradation is extremely dangerous, as this can lead to the release of toxic and explosive gases.\nThe aim of this exercise is to simulate the temperature of a battery pack in order to determine whether it is expected to be safe to use.\nAssume that a constant current \\(I\\) is being drawn from the battery pack. If \\(T_i(t)\\) denotes the temperature of battery \\(i\\) at time \\(t\\), then the temperature of each of the batteries can be obtained by solving the ODE system given by \\[\\begin{align}\nc \\td{T_1}{t} &= I^2 R - h(T_{1} - T_\\text{air}) - h(T_{1} - T_{2}), \\tag{2} \\\\\nc \\td{T_i}{t} &= I^2 R - h(T_{i} - T_{i-1}) - h(T_{i} - T_{i+1}), \\quad i = 2, 3, \\ldots, N - 1, \\tag{3} \\\\\nc \\td{T_N}{t} &= I^2 R - h(T_{N} - T_\\text{air}) - h(T_{N} - T_{N-1}). \\tag{4}\n\\end{align}\\] Here, \\(c\\) is the specific heat of the battery, \\(R\\) is the resistance of the battery, \\(h\\) is the heat transfer coefficient, and \\(T_\\text{air}\\) is the temperature of the air. Values for these parameters are given in the table below. You can assume that the initial temperature of each battery is given by \\(T_\\text{air}\\); that is, \\(T_i(0) = T_\\text{air}\\).\n\nParameter values for each battery.\n\n\n\n\n\n\n\n\n\n\\(I\\) (A)\n\\(c\\) (J/\\(^\\circ\\)C)\n\\(h\\) (W/\\(^\\circ\\)C)\n\\(T_\\text{air}\\) (\\(^\\circ\\)C)\n\\(R\\) (Ohms)\n\n\n\n\n3\n300\n0.7\n23\n0.4\n\n\n\nIn the exercises below, assume that the current is being drawn for one hour.\n\nConsider a battery pack with \\(N = 5\\) batteries.\n\nNumerically solve the ODE system in (2)–(4). Create a single plot that shows the temperature of each battery as a function of time.\nAt each time \\(t\\), compute the maximum temperature across all 6 batteries. Plot the maximum temperature as a function of time.\nUse your results to determine whether the battery is safe to use. Answer: yes.\n\nIs a battery pack with \\(N = 50\\) batteries safe to use? Answer: no.\nWhat is the largest number of batteries that a pack can contain yet still be safe to use? Answer: 11."
  },
  {
    "objectID": "scicomp/week2.html",
    "href": "scicomp/week2.html",
    "title": "Week 2: ODE BVPs",
    "section": "",
    "text": "\\[\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n\\]\n\nOverview\nThis week showcase how finite difference methods can be used to solve boundary value problems (BVPs) for ODEs. In short, the finite difference method converts ODEs into algebraic systems of equations, which can then be solved using two main approaches:\n\nWriting your own solvers using linear algebra functions.\nUsing built-in solvers provided by Python (SciPy) and Matlab.\n\nThe code that you develop this week will form an essential role in the upcoming weeks when the focus shifts towards numerically solving partial differential equations.\n\n\nExercises\nThe goal of the exercises is to create a BVP solver that is capable of finding numerical solutions to ODEs of the form \\[\nD \\tdd{u}{x} + q(x, u; \\mu) = 0,\n\\] where the domain of the problem is given by \\(a \\leq x \\leq b\\). In this equation, \\(D &gt; 0\\) is a parameter. The term \\(q(x, u; \\mu)\\) represents a function that depends on the spatial coordinate \\(x\\), the solution \\(u(x)\\), and a parameter \\(\\mu\\). Your solver should be able to handle all three types of boundary conditions (Dirichlet, Neumann, and Robin).\nBuilding this solver is a big task. The exercises below are designed so that you can see how to build your code by solving a sequence of simpler problems. Test your code extensively and only add complexity once you are certain it works correctly.\n\nUse finite differences to find a numerical solution to \\[\n\\tdd{u}{x} = 0, \\quad\nu(a) = \\gamma_1, \\quad u(b) = \\gamma_2.\n\\] In this case, the exact solution to the problem is given by \\[\nu(x) =  \\left(\\frac{\\gamma_2 - \\gamma_1}{b-a}\\right)(x - a) + \\gamma_1, \\tag{1}\n\\] which you can use to test your code.\nExtend your code so that it can account for a source term in the ODE: \\[\nD \\tdd{u}{x} + q(x) = 0, \\quad\nu(a) = \\gamma_1, \\quad u(b) = \\gamma_2.\n\\] Hint: The simplest place to start is to set \\(q(x) = 1\\); in this case, the exact solution is given by \\[\nu(x) = -\\frac{1}{2D}(x-a)(x-b) +  \\left(\\frac{\\gamma_2 - \\gamma_1}{b-a}\\right)(x - a) + \\gamma_1.\n\\] Once you’ve developed code for the problem with \\(q(x) = 1\\), add an \\(x\\) dependence into \\(q\\). Can you find some exact solutions for this case?\nGeneralise your code so that the source term \\(q\\) can now depend on the solution \\(u\\) as well as a parameter \\(\\mu\\). Use your code to solve the steady Cahn–Hilliard equation \\[\n\\tdd{\\phi}{x} + \\mu(\\phi - \\phi^3) = 0\n\\] with the boundary conditions \\(\\phi(-1) = -1\\) and \\(\\phi(1) = 1\\) when (a) \\(\\mu = 0.5\\) and (b) \\(\\mu = 10\\).\nHint 1: If \\(q\\) depends nonlinearly on the solution, as with this problem, then a good initial guess of the solution is usually required for the nonlinear solver to converge. For this problem, a good initial guess can be found by noting that when \\(\\mu\\) is small, the source term \\(q\\) is approximately zero. The solution in this case is given by (1), which can be used to form an initial guess.\nHint 2: If you find it difficult to obtain a solution when \\(\\mu = 10\\), then try to increase \\(\\mu\\) in small increments from \\(0.5\\) to \\(10\\). Each time a new solution is successfully computed, it is used as the initial guess for the next (larger) value of \\(\\mu\\). This process of gradually ramping up a parameter and using the previously computed solution as the next initial guess is called natural parameter continuation.\nUpdate your code so that it can account for any combination of Dirichlet, Neumann, and Robin boundary conditions.\n\nTry using your code to solve the problem \\[\n\\tdd{u}{x} + 1 = 0, \\quad \\left.\\td{u}{x}\\right|_{x=\\pm 1} = 0.\n\\] To understand what happens, try solving this problem by hand."
  },
  {
    "objectID": "optim/overview.html",
    "href": "optim/overview.html",
    "title": "Scientific Computing: Overview",
    "section": "",
    "text": "Weeks 7–11\nThe purpose of this bit is…"
  },
  {
    "objectID": "assessment.html",
    "href": "assessment.html",
    "title": "Assessment",
    "section": "",
    "text": "This unit will be assessed by a single piece of coursework. It will be released in two parts, one in week 5 and one in week 9.\nThe final deadline is 12 noon on Friday of week 11. Submit your coursework as a PDF via Blackboard."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing and Optimisation",
    "section": "",
    "text": "This unit will bring together your previous experience of solving mathematical problems (optimisation, differential equations) and writing computer programmes using Python, Matlab, or Julia. The aim is to provide you with a suite of tools that can be used to transform real-world problems, such as those encountered in the Mathematical and Data Modelling units and final-year projects, into problems that can be efficiently solved on a computer.\n\nUnit timetable\n\nWeek 1: Finite differences and Euler’s method\nWeek 2: ODE boundary value problems\nWeek 3: Diffusion equations in 1D\nWeek 4: First-order PDEs in 1D\nWeek 5: The 2D Poisson equation\nWeek 6: Reading week (no sessions)\nWeek 7:\nWeek 8:\nWeek 9:\nWeek 10:\nWeek 11: Coursework support\nWeek 12: TBD\n\n\n\nTeaching sessions\nAll teaching sessions will take place in MVB 1.15.\n\nMonday ????: demo and Q&A session\nThursday 1600-1800: lab session\nFriday ????: drop-in (optional)\n\n\n\nTeaching staff\n\nDr Matthew Hennessy (unit director): matthew.hennessy@bristol.ac.uk\nProf David Barton (unit lecturer): david.barton@bristol.ac.uk\nMr Roussel Desmond Nzoyem (teaching assistant): rd.nzoyemngueguin@bristol.ac.uk"
  },
  {
    "objectID": "scicomp/overview.html",
    "href": "scicomp/overview.html",
    "title": "Scientific Computing: overview",
    "section": "",
    "text": "The first five weeks will focus on how scientific computing can be applied to the numerical solution of ordinary and partial differential equations. Although differential equations appear in many engineering contexts, they usually cannot be solved by hand. Instead, numerical methods are needed to compute an approximate solution.\n\nWeek 1: Finite differences and Euler’s method\nWeek 2: ODE boundary value problems\nWeek 3: Diffusion equations in 1D\nWeek 4: First-order PDEs in 1D\nWeek 5: The 2D Poisson equation"
  }
]