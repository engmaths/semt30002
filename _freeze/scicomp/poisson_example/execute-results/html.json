{
  "hash": "8657136d1936bd324191485241f83722",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Example code for the 2D Poisson equation\"\njupyter: python3\n---\n\n$$\n\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}\n\\newcommand{\\td}[2]{\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}}\n\\newcommand{\\tdd}[2]{\\frac{\\mathrm{d}^2#1}{\\mathrm{d}#2^2}}\n\\newcommand{\\pd}[2]{\\frac{\\partial#1}{\\partial#2}}\n\\newcommand{\\pdd}[2]{\\frac{\\partial^2#1}{\\partial#2^2}}\n$$\n\n\n\n# Overview\n\nThe code below solves the Poisson equation\n$$\n\\pdd{u}{x} + \\pdd{u}{y} + q = 0\n$$\nwhere $q$ is a constant on a rectangular domain given by $a \\leq x \\leq b$ and $c \\leq y \\leq d$.  Dirichlet boundary conditions given by $u = 0$ are imposed at all four boundaries.\n\n# Code\n\n::: {#87ed63c3 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.optimize import root\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\n\"\"\" \nset up the problem parameters\n\"\"\"\n\n# domain parameters\na = 0\nb = 1\nc = 0\nd = 1\n\n# number of grid points\nNx = 20\nNy = 20\n\n# Value of the constant source term\nq = 1\n\n\"\"\"\nconstruct the grid    \n\"\"\"\n\n# grid points\nx = np.linspace(0, 1, Nx+1)\ny = np.linspace(0, 1, Ny+1)\nx_int = x[1:Nx]\ny_int = y[1:Ny]\n\n# grid spacing in x and y directions\ndx = (b - a) / Nx\ndy = (d - c) / Ny\n\n# total number of unknowns\ndof = (Nx - 1) * (Ny - 1)\nprint('There are', dof, 'unknowns to solve for')\n\n# mapping from grid indices (i,j) to global indices (k)\nk = lambda i,j : i + (Nx - 1) * j\n\n\"\"\"\nSetting the initial guess of the solution, which is assumed\nto be given by u(x,y) = x*y*(1-x)*(1-y).  First we\ncreate this as a 2D array named u_0.  Then we convert\nthe 2D array into a 1D array named U_0.  Notice how the\nmapping function k defined above is used to calculate\nthe indices of the 1D array using the two local grid\nindices i and j\n\"\"\"\n\n# pre-allocate the 2D array\nu_0 = np.zeros((Nx - 1, Ny - 1))\n\n# use a double for loop to create the initial guess as a 2D array\n\nfor i in range(Nx - 1):\n    for j in range(Ny - 1):\n        u_0[i, j] = x_int[i]*y_int[j]*(1-x_int[i])*(1-y_int[j])\n\n# pre-allocate the 1D array\nU_0 = np.zeros((Nx - 1) * (Ny - 1))\n\n# use a double for loop to store each u[i,j] in U_k\nfor i in range(Nx - 1):\n    for j in range(Ny - 1):\n        U_0[k(i,j)] = u_0[i,j]\n\n\n\"\"\"\nFunction to pass to SciPy's root.  This function\nbuilds the algebraic system in the form F(U) = 0,\nwhere U is a 1D array that contains the solution\ncomponents at all interior grid points.  The code\nbelow is not optimal and improvements can be made.\n\"\"\"\n\ndef dirichlet_problem(U):\n\n    # Pre-allocation of 2D arrays\n    u = np.zeros((Nx-1, Ny-1))\n    F = np.zeros((Nx-1, Ny-1))\n\n    # Convert the 1D soln array U[k] into a 2D array u[i,j]\n    for i in range(0, Nx - 1):\n        for j in range(0, Ny - 1):\n            u[i,j] = U[k(i,j)]\n    \n    # Build the algebraic system as a 2D array F[i,j]\n    for i in range(0, Nx - 1):\n        for j in range(0, Ny - 1):\n\n            # near x = a boundary\n            if i == 0 and 0 < j < Ny - 2:\n                F[i,j] = (\n                    (u[i+1,j] - 2 * u[i,j] + 0) / dx**2 + \n                    (u[i,j+1] - 2 * u[i,j] + u[i,j-1]) / dy**2 + \n                    q\n                )\n\n            # near x = b boundary\n            elif i == Nx - 2 and 0 < j < Ny - 2:\n                F[i,j] = (\n                    (0 - 2 * u[i,j] + u[i-1,j]) / dx**2 + \n                    (u[i,j+1] - 2 * u[i,j] + u[i,j-1]) / dy**2 + \n                    q\n                )\n                \n            # near y = c boundary\n            elif j == 0 and 0 < i < Nx - 2:\n                F[i,j] = (\n                    (u[i+1,j] - 2 * u[i,j] + u[i-1,j]) / dx**2 + \n                    (u[i,j+1] - 2 * u[i,j] + 0) / dy**2 + \n                    q\n                )\n\n            # near y = d boundary\n            elif j == Ny - 2 and 0 < i < Nx - 2:\n                F[i,j] = (\n                    (u[i+1,j] - 2 * u[i,j] + u[i-1,j]) / dx**2 + \n                    (0 - 2 * u[i,j] + u[i,j-1]) / dy**2 + \n                    q\n                )\n\n            # near x = a, y = c corner\n            elif i == 0 and j == 0:\n                F[i,j] = (\n                    (u[i+1,j] - 2 * u[i,j] + 0) / dx**2 + \n                    (u[i,j+1] - 2 * u[i,j] + 0) / dy**2 + \n                    q\n                )\n\n            # near x = a, y = d corner\n            elif i == 0 and j == Ny - 2:\n                F[i,j] = (\n                    (u[i+1,j] - 2 * u[i,j] + 0) / dx**2 + \n                    (0 - 2 * u[i,j] + u[i,j-1]) / dy**2 + \n                    q\n                )\n\n            # near x = b, y = c corner\n            elif i == Nx - 2 and j == 0:\n                F[i,j] = (\n                    (0 - 2 * u[i,j] + u[i-1,j]) / dx**2 + \n                    (u[i,j+1] - 2 * u[i,j] + 0) / dy**2 + \n                    q\n                )\n\n            # near x = b, y = d corner\n            elif i == Nx - 2 and j == Ny - 2:\n                F[i,j] = (\n                    (0 - 2 * u[i,j] + u[i-1,j]) / dx**2 + \n                    (0 - 2 * u[i,j] + u[i,j-1]) / dy**2 + \n                    q\n                )\n\n            # grid points not adjacent to a boundary\n            else:\n                F[i,j] = (\n                    (u[i+1,j] - 2 * u[i,j] + u[i-1,j]) / dx**2 + \n                    (u[i,j+1] - 2 * u[i,j] + u[i,j-1]) / dy**2 + \n                    q\n                )\n\n    # Now the 2D array for F[i,j] needs to be converted into a\n    # 1D array of the form F[k]\n    F_1d = np.zeros((Nx-1) * (Ny-1))\n    for i in range(Nx-1):\n        for j in range(Ny-1):\n            F_1d[k(i,j)] = F[i,j]\n\n    \n    # return the 1D array\n    return F_1d\n\n\n\"\"\"\nSolve the algebraic system using SciPy's root function\n\"\"\"\n\n# Solve\nsol = root(dirichlet_problem, U_0)\n\n# Check for convergence\nprint(f'Did root converge: {sol.success}')\nU = sol.x\n\n\"\"\"\nturn the 1D solution array U into a 2D array u\n\"\"\"\nu = np.zeros((Nx-1, Ny-1))\nfor i in range(Nx-1):\n    for j in range(Ny-1):\n        u[i,j] = U[k(i,j)]\n\n\n\"\"\"\nnow we plot the solution\n\"\"\"\n\n# turn the 1D arrays for x_int and y_int\n# into 2D arrays for plotting\nxx, yy, = np.meshgrid(x_int, y_int)\n\n# due to how the global index function k(i,j) is defined\n# we need to plot the transpose of u rather than u\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\nax.plot_surface(xx, yy, u.T, cmap=cm.coolwarm)\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_zlabel(\"u\")\nfig.tight_layout()\n\n# contour plots are often better to use because \n# all the features can be seen\nplt.figure()\nplt.contourf(xx, yy, u.T, 50, cmap = cm.coolwarm)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.colorbar()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are 361 unknowns to solve for\nDid root converge: True\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](poisson_example_files/figure-html/cell-2-output-2.png){width=489 height=470}\n:::\n\n::: {.cell-output .cell-output-display}\n![](poisson_example_files/figure-html/cell-2-output-3.png){width=585 height=429}\n:::\n:::\n\n\n",
    "supporting": [
      "poisson_example_files"
    ],
    "filters": [],
    "includes": {}
  }
}